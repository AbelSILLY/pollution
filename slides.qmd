---
title: "Étude de la pollution de l'air en Occitanie"
author: "Ibrahim ATTOUMANI, Tristan RIVALDI, Kilian SAINT-CHÉlY, Abel SILLY, Jeanne VIVIER"
format: 
    revealjs :
        transition: slide
        background-transition: fade
---

# Une première approche

## Introduction

![](cycles-pollution.png)


- Quelles sont les principales causes et effets de la pollution de l'air en Occitanie ?

## {auto-animate=true}

- 



## But de l'étude 

- Quels sont les principaux polluants et quels sont leurs impacts sur notre santé et l'environnement ?
    -  Apprivoisement du sujet
    - La première prise en main des données

- Une répartition inégale en Occitanie ? 
    - Découpage progressif de la carte
    - Choix des données
    - Choix des représentations

- L'influence de la météo ?
    - 


# État des lieux 

```{python}

import matplotlib.pyplot as plt

# Données à afficher
labels = ['Résidentiel/Tertiaire', 'Transport routier', 'Industrie manufacturière', 'Agriculture', 'Transformation de l\'énergie', 'Autre']
pourcentages = [62, 17, 11, 6, 2, 2]

# Couleurs
colors = plt.cm.Paired(range(len(labels)))

# Création du graphique en forme de donuts
fig, ax = plt.subplots()
wedges, texts, autotexts = ax.pie(pourcentages, labels=None, autopct='', startangle=90, colors=colors)

# Ajout des pourcentages sans chevauchement
for i, (text, autotext) in enumerate(zip(texts, autotexts)):
    angle = wedges[i].theta2 - wedges[i].theta1
    if angle >= 10:  # Éviter l'affichage des pourcentages pour les petits segments
        x, y = autotext.get_position()
        distance = 1.15  # Facteur d'espacement des pourcentages
        ax.text(x * distance, y * distance, '{:.1f}%'.format(pourcentages[i]), ha='center', va='center')

# Dessiner un cercle au centre pour transformer le pie chart en donut chart
centre_cercle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_cercle)

# Ajout de la légende
legend_labels = ['{} - {:.1f}%'.format(label, percentage) for label, percentage in zip(labels, pourcentages)]
ax.legend(wedges, legend_labels, title="Secteurs d'activité", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))

# Ajustements
ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.suptitle('D\'après le ministère de l\'environnment', fontstyle='italic' )
plt.title('Origine des particules PM10 en France (2014)')

# Affichage du graphique
plt.show()


```

## {auto-animate=false}
```{python}
import matplotlib.pyplot as plt

# Données à afficher
labels = ['Résidentiel/Tertiaire', 'Transport routier', 'Industrie manufacturière', 'Agriculture', 'Transformation de l\'énergie', 'Autre']
pourcentages = [62, 17, 11, 6, 2, 2]

# Couleurs avec transparence (alpha)
colors = [(0.8, 0.8, 0.8, 0.6), (0.8, 0.8, 0.8, 0.6), (0.8, 0.8, 0.8, 0.6), (0.8, 0.8, 0.8, 0.6), (1.0, 0.65, 0.0, 0.8), (0.8, 0.8, 0.8, 0.6)]  # Opacité réduite pour tous

# Création du graphique en forme de donuts
fig, ax = plt.subplots()
wedges, texts, autotexts = ax.pie(pourcentages, labels=None, autopct='', startangle=90, colors=colors)

# Ajout des pourcentages sans chevauchement
for i, (text, autotext) in enumerate(zip(texts, autotexts)):
    angle = wedges[i].theta2 - wedges[i].theta1
    if angle >= 10:  # Éviter l'affichage des pourcentages pour les petits segments
        x, y = autotext.get_position()
        distance = 1.15  # Facteur d'espacement des pourcentages
        ax.text(x * distance, y * distance, '{:.1f}%'.format(pourcentages[i]), ha='center', va='center')

# Dessiner un cercle au centre pour transformer le pie chart en donut chart
centre_cercle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_cercle)

# Ajout de la légende
legend_labels = ['{} - {:.1f}%'.format(label, percentage) for label, percentage in zip(labels, pourcentages)]
ax.legend(wedges, legend_labels, title="Secteurs d'activité", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))

# Ajustements
ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.suptitle('D\'après le ministère de l\'environnement', fontstyle='italic' )
plt.title('Origine des particules PM10 en France (2014)')

# Affichage du graphique
plt.show()
```
## Production d'électricité en Occitanie

![](rte.png)




L'utilisation des données de RTE ne nous a pas semblé si pertinante...      
 _Source : RTE, production d'électricité en 2022 en Occitanie_     
[(https://www.rte-france.com/actualites/bilan-electrique-2022-occitanie#:~:text=Avec%2029%2C1%20TWh%2C%20la,hauteur%20de%2098%2C5%20%25.)]


## Dinner

- Eat spaghetti
- Drink wine

# Construction du projet

## Les choix
- Pas les données de RTE finalement
- Zooms spaciaux - temporels 
- Choix des villes 

## Création d'un module 

## Création de classe

## Les difficultés

- Liées au projet
    - Appréhender le sujet correctement 
    - Organiser les idées et le travail
    - Éviter le travail inutile
    - Coodroner un groupe

- Informatiques
    - La prise en main des outils
    - La création d'un module
    - Le déploiement du site 


# Affichage et accessibilité 

## Graphiques
```{python}
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import folium
import requests

# initialisation d'un dataframe à partir d'un fichier local contenant les géométries (polygone) de l'Occitanie
couche = gpd.read_file("C:\\Users\\BossdiDibosS\\Desktop\\pollution\\modpollution\\data\\polyg_geom.geojson")

# Définir l'URL
url = "https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/Indice_quotidien_de_qualité_de_l’air_pour_les_collectivités_territoriales_en_Occitanie/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"
# url = "https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/mesures_occitanie_72h_poll_princ/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

# Effectuer une requête pour récupérer les données GeoJSON
response = requests.get(url)
data = response.json()

# Créer un GeoDataFrame à partir des données GeoJSON
gdf = gpd.GeoDataFrame.from_features(data['features'])

# gdf = gdf.merge(couche[['geometry']], left_index=True, right_index=True, suffixes=('', '_couche'))
# geopollu = gdf.rename(columns={'geometry_couche': 'polyg_geom'})

# On assigne les colones 'geometry' et 'nom_officiel_departement' au geodataframe gdf
gdf = gdf.assign(geometry=couche['geometry'])
gdf = gdf.assign(nom_officiel_departement=couche['nom_officiel_departement'])

# Afficher les premières lignes du GeoDataFrame
gdf.head()


# Créer une figure avec deux sous-plots côte à côte
fig, axs = plt.subplots(1, 2, figsize=(10, 5))

# Plot 1 : Carte avec la colonne 'code_o3'
axs[0].set_title('Carte - Code O3')
gdf.plot(column='code_o3', cmap='Spectral', linewidth=0.8, ax=axs[0], edgecolor='0.8', legend=True)

# Ajouter des étiquettes pour chaque département
for x, y, label in zip(gdf.geometry.centroid.x, gdf.geometry.centroid.y, gdf['nom_officiel_departement']):
    axs[0].annotate(label, xy=(x, y), xytext=(3, 3), textcoords='offset points')

# Plot 2 : Carte avec la colonne 'code_pm10'
axs[1].set_title('Carte - Code PM10')
gdf.plot(column='code_pm10', cmap='Spectral', linewidth=0.8, ax=axs[1], edgecolor='0.8', legend=True)

# Ajouter des étiquettes pour chaque département
for x, y, label in zip(gdf.geometry.centroid.x, gdf.geometry.centroid.y, gdf['nom_officiel_departement']):
    axs[1].annotate(label, xy=(x, y), xytext=(3, 3), textcoords='offset points')

# Ajuster l'espacement entre les sous-plots
plt.tight_layout()

# Afficher les plots
plt.show()
```
- Matplotlib
- Graphiques horaires pour les données journalières
- Histogrammes 
- Courbes 
On explique pourquoi on choisit cela


## Interactivité 

- Carte interactive 
- Graphiques ineractifs

## Accessibilité du site web

- Page d'accueil
- Trouver les infos facilement 

## Des idées pour agir ? {transition="fade-in slide-out"}
- À l'échelle municipale 
    - 
    - 

- À l'échelle départementale 
    - Ecourager le covoiturage 
    -  

- À l'échelle régionale 
    - Limiter les vols internes
    - Développer les lignes ferroviaires
