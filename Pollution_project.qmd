On utilise quatres urls contenant les données de pollutions sur l'Occitanie entre 2016 et 2019. Ensuite, nous allons initialiser un data frame  afin d'étudiée ces données.

```{python}
import pandas as pd
import numpy as np
import requests
import folium
from datetime import datetime, timedelta

# Liste des URL à récupérer
urls = [
    "https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/fl_emi_occitanie_epci/FeatureServer/6/query?where=1%3D1&outFields=*&outSR=4326&f=json",
    "https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/fl_emi_occitanie_epci/FeatureServer/7/query?where=1%3D1&outFields=*&outSR=4326&f=json",
    "https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/fl_emi_occitanie_epci/FeatureServer/8/query?where=1%3D1&outFields=*&outSR=4326&f=json",
    "https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/fl_emi_occitanie_epci/FeatureServer/9/query?where=1%3D1&outFields=*&outSR=4326&f=json"
]

# Initialiser une liste pour stocker les DataFrames
data_frames = []

# Temps d'attente maximal en secondes
timeout_seconds = 60
```

Ici on concaténe les quatres ulrs pour créer un seule data frame.

```{python}
# Récupérer les données JSON de chaque URL et les convertir en DataFrame
for url in urls:
    start_time = datetime.now()
    response = requests.get(url)
    elapsed_time = datetime.now() - start_time
    
    # Vérifier si le temps d'attente maximal est dépassé
    if elapsed_time.total_seconds() > timeout_seconds:
        print("Le téléchargement depuis l'URL {} a pris trop de temps. Passer à l'URL suivante.".format(url))
        continue

    data = response.json()
    features = data.get('features', [])
    if features:
        df = pd.json_normalize(features)
        data_frames.append(df)

```



```{python}
# Concaténation les DataFrames en un seul
final_df = pd.concat(data_frames, ignore_index=True)
```

on insert les données dans la carte et fonction de la concentration on pourra observer une differentiation par une couleur.

```{python}
# Création d'une nouvelle carte Folium
m = folium.Map(location=[44.0, 3.0], zoom_start=6)

# Parcourt toutes les lignes du DataFrame df
for index, row in df.iterrows():
    # Obtient les coordonnées de la ligne
    coords = [row['geometry.rings'][0][0][0], row['geometry.rings'][0][0][1]]
    
    # Obtient la concentration de pollution s'il existe, sinon, utilise une valeur par défaut
    concentration = row['attributes.nox_kg']  # Remplacez 'nox_kg' par le nom de la colonne correspondante
    pollution_type = row['attributes.lib_epci']  # Remplacez 'lib_epci' par le nom de la colonne correspondante
    
    # Détermine la couleur en fonction de la concentration
    if concentration < 66555:
        color = 'green'
    elif concentration < 109240:
        color = 'yellow'
    elif concentration < 161250:
        color = 'orange'
    else:
        color = 'red'

    # Ajoute un marqueur à la carte pour cette caractéristique avec la couleur appropriée
    marker = folium.CircleMarker(location=coords[::-1], radius=5, color=color, fill=True, fill_color=color)
    
    # Ajoute un popup avec les informations de concentration et de type de pollution
    popup_text = f'Département: {pollution_type}<br>Concentration NOx_kg: {concentration}'#NOx (oxyde d'azote) polluants atmosphérique
    folium.Popup(popup_text, max_width=300).add_to(marker)
    
    marker.add_to(m)

```

Voici la carte après traittement.

```{python}
# Affiche la carte
m
```